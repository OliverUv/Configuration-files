
" Fix for my shell, otherwise some scripts break
if $SHELL =~ 'bin/fish'
    set shell=/bin/sh
endif

" Automatic commands {{{ "
if has("autocmd")
augroup MyAutoCmd
    " Clear autocmds for this group
    autocmd!

    " Automatically load vimrc when it is saved
    " autocmd bufwritepost .vimrc source $MYVIMRC
    " autocmd BufWritePost .vimrc,_vimrc,vimrc,.gvimrc,_gvimrc,gvimrc
    "       \ so $MYVIMRC | if has('gui_running') | so $MYGVIMRC | endif

    " Mapping for checking for existing mappings in vimrc
    autocmd BufEnter .vimrc,vimrc,.gvimrc,gvimrc,.vim8_nvim_rc.vim,init.vim
          \ nnoremap <leader>' /leader>

    " Set ghc as compiler for haskell files
    autocmd BufEnter *.hs compiler ghc

    " Disable foldcolumn in diff windows
    au FilterWritePre * if &diff | setlocal fdc=0 | endif

    " Sytax highlight from start of file
    autocmd BufEnter * :syntax sync fromstart

    " Disable things that disturb diff-colors in diff window
    if ! has('nvim')
        au FilterWritePre * if &diff | setlocal nocursorcolumn | endif
        au FilterWritePre * if &diff | setlocal nocursorline | endif
        au FilterWritePre * if &diff | IndentGuidesDisable | endif
    endif

    " Disable indent guide in term
    au TermOpen * IndentGuidesDisable
augroup end
endif
" }}} Automatic commands "

" Custom commands {{{ "
" :Configure to edit this file in a split window
command! Configure edit $MYVIMRC
command! SConfigure split $MYVIMRC
command! VConfigure vsplit $MYVIMRC

" :Cdpwd to set current window's pwd to the edited file's directory
command! Cdpwd lcd %:p:h

" :Q to quit
command! Q q
command! Qall qall

" Recover a file then write :DiffOrig to see
" a vimdiff between the recovery and the original.
" (sort of superceded by recover.vim)
command! DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis | wincmd p | diffthis

" Copy current file path into os buffer
command! Ypwd let @+ = expand("%:p")
command! Ypfilename let @+ = expand("%:t")

" Insert random data generated by openssl
command! Pass read !openssl rand -base64 32

" }}} Custom commands "

" Basic settings {{{ "
syntax enable           " Enables syntax highlighting with custom colors
filetype plugin indent on " React on filetypes with plugins and syntax
set scrolloff=2         " Minimum number of lines to display around cursor
set sidescroll=1        " Number of cols to autoscroll when reaching end of nowrap line
set sidescrolloff=40    " Number of cols of text to show on the right of caret, minimum
set autoread            " Files changed from outside are automatically reread
set hlsearch            " Highlight search results
set mousehide           " Hide the mouse when typing text
set smarttab            " <TAB> inserts 'shiftwidth' spaces
set shiftwidth=4        " Amount of spaces for tab to insert
set autoindent          " Automatically set the indent when creating new lines.
set expandtab           " Makes <tab> insert spaces in insert mode
set breakindent         " Makes vim display visually wrapped lines with correct indentation
set breakindentopt=min:20,shift:-2
set showbreak=↳\ 
set showcmd             " Shows current command in statusline
set ruler               " Show cursor position information in statusline
set cursorcolumn
set cursorline
set relativenumber      " Show relative line numbers by default
set number              " Show absolute line number of current line
set wrap                " Wrap text
"set list               " Show listchars
set ttyfast             " 'Smooth' scrolling
set mouse=a             " Enable mouse in terminals that support it
set showmatch           " Briefly display matching brackets when inserting such.
set incsearch           " Incremental searching as soon as typing begins.
set ignorecase          " Ignores case when searching
set smartcase           " Will override ignorecase if searching w/ diff cases.
set modeline            " Use modelines
set wildchar=<TAB>      " Key that triggers command-line expansion.
set wildmenu            " Completion on commandline
set wildmode=longest:full " Commandline completion mode
set noerrorbells        " Disables beeping.
set hidden              " Allow switch buffer without saving
set previewheight=15    " Height of the preview window
"set winwidth=80        " Current window will be resized to this width
set switchbuf=useopen   " If switching to a buffer that is already open, go
                        " to where it is already open instead of here.
set backspace=indent,eol,start whichwrap+=<,>,[,] " backspace functionality
set foldopen-=search     " Don't open a fold just because a search lands on it
set formatprg=par        " user par to format text with the gq command
set formatoptions=croqlj " auto formatting options
                         " c - autowrap using textwidth
                         " r - autoinsert comment leader on i_<enter>
                         " q - allow formatting of comments with gq
                         " l - long lines aren't broken
                         " j - remove comment leader when joining lines
set noea                 " prevent equalizing of split sizes on closed split
set fillchars=fold:\ ,vert:\  " fill characters for fold lines and lines between vsplits
set ttimeoutlen=50      " Faster twitchin' for everything
set tildeop             " Tilde acts as an operator (no need to g~ to switch case with motions)
set iskeyword+=å,ä,ö    " Add swedish characters to iskeyword
set virtualedit=block   " Allow cursor to be moved into empty space while in visual mode
set display=lastline    " Show last line at bottom of window, even if it can't be displayed entirely
set noshowmode          " Don't show that we're in insert mode
set concealcursor=""    " Don't do syntax based conceal when cursor is on same line
set updatetime=90       " How long in ms to wait after stop typing to update things, use that CPU baby, burn those cycles
set undolevels=5000     " More undo storage
" set spellfile=$HOME/.vim/spell/ TODO
if executable('rg')
    set grepprg=rg\ --vimgrep
endif

if (v:version > 703)
    set undofile
endif

" Make Vim able to edit crontab files again.
set backupskip=/tmp/*,/private/tmp/*"
" }}} Basic settings "

" Completion ignores {{{ "
" KEEP THESE IN SYNC WITH UNITE IGNORES!
" Never put .git in here!

set wildignore+=*/.hg/*,*/.svn/*,*.pyc,*pb2.py,*.class,*.min.js
set wildignore+=.ropeproject/**
set wildignore+=log/**
set wildignore+=tmp/**
set wildignore+=obj/**
set wildignore+=*.pbxproj,*.xcodeproj,Altitude-OSX.order,*.vcproj

" Ignore output and VCS files: Note: do not ignore .git! It breaks fugitive's :Gdiff
set wildignore+=*.o,*.out,*.obj,*.rbc,*.rbo,*.class,.svn,*.gem

" Ignore archive files
set wildignore+=*.zip,*.tar.gz,*.tar.bz2,*.rar,*.tar.xz

" Ignore image files
set wildignore+=*.jpg,*.jpeg,*.bmp,*.png,*.gif

" Ignore bundler and sass cache
set wildignore+=*/vendor/gems/*
set wildignore+=*/vendor/cache/*
set wildignore+=*/.bundle/*
set wildignore+=*/.sass-cache/*

" Ignore rails temporary asset caches
set wildignore+=*/tmp/cache/assets/*/sprockets/*
set wildignore+=*/tmp/cache/assets/*/sass/*

" Ignore modules / components
set wildignore+=*/node_modules/*
set wildignore+=bower_components/*
set wildignore+=libs/*
set wildignore+=typings/*

" Ignore build artifacts
set wildignore+=build/*
set wildignore+=dist/*

" Ignore tag files
set wildignore+=tags,*.taghl

" Ignore temp and backup files
set wildignore+=*.swp,*~,._*

" Ignore thirdparty assets
set wildignore+=*/thirdparty/*
set wildignore+=*web/static/components/*
set wildignore+=*web/static/images/*
set wildignore+=*web/static/external/*

" Ignore Debug and Release folders
set wildignore+=*/Debug/*,*/Release/*
" }}} Completion ignores "

" Filetype specific settings {{{ "

" Build scripts {{{ "
function! g:BuildClang(config, doclean)
    " From Syntastic, to be used with clang
    " -fshow-column
    " -fshow-source-location
    " -fno-caret-diagnostics
    " -fno-color-diagnostics
    " -fdiagnostics-format=clang
    let errorformat =
            \ '%E%f:%l:%c: fatal error: %m,' .
            \ '%E%f:%l:%c: error: %m,' .
            \ '%W%f:%l:%c: warning: %m,' .
            \ '%-G%\m%\%%(LLVM ERROR:%\|No compilation database found%\)%\@!%.%#,' .
            \ '%E%m'

    exec "make -C " . a:config . "/ -j4 " . a:doclean
    silent exec "!$HOME/bin/done"
endfunction
" }}} Build scripts "


if has("autocmd")
    augroup MyFtCommands
    " Clear autocmds for this group
    autocmd!

    " Rice Operators {{{ "

    function Riceoperators(ft)
        " if !exists('w:hasricedoperators')
            setl conceallevel=1
            " Priorities must be lower than the matches for hlsearch,
            " otherwise all hlsearch hilighted things are concealed
            " https://github.com/vim/vim/issues/2185
            " call matchadd('Conceal', '^\s*[^/][^/].*\zs!==\ze', -1, -1, {'conceal': '≠'})
            if a:ft == "typescript"
                call matchadd('Conceal', '!==', -1, -1, {'conceal': '≠'})
                call matchadd('Conceal', '===', -1, -1, {'conceal': '≗'})
            endif
            call matchadd('Conceal', '==', -2, -1, {'conceal': '≡'})
            call matchadd('Conceal', '!=', -2, -1, {'conceal': '≢'})
            call matchadd('Conceal', '<=', -2, -1, {'conceal': '≤'})
            call matchadd('Conceal', '>=', -2, -1, {'conceal': '≥'})
            if a:ft == "typescript"
                call matchadd('Conceal', '=>', -2, -1, {'conceal': '⇒'})
                call matchadd('Conceal', '->', -2, -1, {'conceal': '→'})
            endif
            call matchadd('Conceal', '&&', -2, -1, {'conceal': '⋀'})
            call matchadd('Conceal', '||', -2, -1, {'conceal': '⋁'})
            call matchadd('Conceal', '+=', -2, -1, {'conceal': '⊞'})
            call matchadd('Conceal', '-=', -2, -1, {'conceal': '⊟'})
            " Because JS has both `for in` and `for of`, I'm not enabling this for now
            " call matchadd('Conceal', 'for\s*([^)]*\s\+\<\zsin\ze\>', -2, -1, {'conceal': '∈'})
            call matchadd('Conceal', '\s\zs=\ze\s', -3, -1, {'conceal': '⇐'})
        " endif
        " let w:hasricedoperators=1
    endfunction

    " }}} Rice Operators " 

    " arduino {{{ "
    au FileType arduino nnoremap <silent> <leader>ov :split<cr><c-w>j:<C-u>ArduinoVerify<cr>A
    au FileType arduino nnoremap <silent> <leader>oo :split<cr><c-w>j:<C-u>ArduinoUpload<cr>A
    au FileType arduino nnoremap <silent> <leader>oO :split<cr><c-w>j:<C-u>ArduinoUploadAndSerial<cr>A
    au FileType arduino nnoremap <silent> <leader>os :split<cr><c-w>j:<C-u>ArduinoSerial<cr>A
    au FileType arduino let g:arduino_serial_port = '/dev/ttyACM0'
    au FileType arduino let g:arduino_serial_baud = '9600'
    au FileType arduino let g:arduino_serial_cmd = 'picocom {port} -b {baud} -l'
    " au FileType arduino let g:arduino_serial_tmux = 'split-window -d'
    au FileType arduino let g:arduino_serial_tmux = ''
    " }}} arduino "

    " typescript {{{ "
    au FileType typescript setlocal expandtab shiftwidth=2 softtabstop=2 omnifunc=tsuquyomi#complete
    au FileType typescript nmap <buffer> <Leader>jg :TsuquyomiImplementation<CR>
    au FileType typescript nmap <buffer> <Leader>ji :TsuquyomiImport<CR>
    au FileType typescript nmap <buffer> <Leader>jq :TsuquyomiQuickFix<CR>
    au FileType typescript nmap <buffer> <Leader>jr :TsuquyomiRenameSymbol<CR>
    au FileType typescript nmap <buffer> <Leader>jR :TsuquyomiRenameSymbolC<CR>
    au FileType typescript nmap <buffer> <Leader>js :TsuquyomiSignatureHelp<CR>
    au FileType typescript nmap <buffer> <Leader>jt :TsuquyomiTypeDefinition<CR>
    au FileType typescript nmap <buffer> <Leader>ju :TsuquyomiReferences<CR>
    au FileType typescript nmap <buffer> <Leader>jz :TsuquyomiOpen<CR>
    au FileType typescript nmap <buffer> <Leader>jZ :TsuquyomiStopServer<CR>:TsuquyomiStartServer<CR>:TsuquyomiOpen<CR>
    au FileType typescript nnoremap <silent> <leader>lf :<C-u>Unite tsproject<CR>

    au FileType typescript nmap <buffer> K :<C-u>echo tsuquyomi#hint()<CR>
    au FileType typescript nmap <buffer> <Leader>fk :<C-u>echo tsuquyomi#hint()<CR>
    au FileType typescript nmap <buffer> <Leader>jk :<C-u>echo tsuquyomi#hint()<CR>

    au FileType typescript let b:splitjoin_trailing_comma = 1

    au FileType typescript let g:neomake_serialize = 1
    au FileType typescript let g:neomake_serialize_abort_on_error = 1
    au FileType typescript nnoremap <silent> <leader>oo :<C-u>Neomake! tsc tslint<cr>
    au FileType typescript nnoremap <silent> <leader>oO :<C-u>Neomake! tsc<cr>
    au FileType typescript nnoremap <silent> <leader>of :<C-u>TsuquyomiGeterrProject<cr>

    au BufWinEnter *.ts,*.tsx call Riceoperators("typescript")
    au WinEnter *.ts,*.tsx call Riceoperators("typescript")
    " }}} typescript "

    " rust {{{ "
    " au FileType rust setlocal omnifunc=LanguageClient#complete
    " au FileType rust nnoremap <buffer> <silent> K :call LanguageClient#textDocument_hover()<cr>
    " au FileType rust nnoremap <buffer> <silent> <leader>jh :call LanguageClient#textDocument_documentHighlight()<CR>
    " au FileType rust nnoremap <buffer> <silent> <leader>jg :call LanguageClient#textDocument_definition()<CR>
    " au FileType rust nnoremap <buffer> <silent> <leader>jr :<c-u>Denite references<cr>
    " au FileType rust nnoremap <buffer> <silent> <leader>jR :call LanguageClient#textDocument_rename()<CR>
    au BufWinEnter *.rs call Riceoperators("rust")
    au WinEnter *.rs call Riceoperators("rust")
    " }}} rust "

    " cpp {{{ "
    au FileType cpp setlocal list expandtab shiftwidth=4 softtabstop=4

    au FileType cpp nnoremap <silent> <leader>oo :call g:BuildClang("Debug", "")<cr>
    au FileType cpp nnoremap <silent> <leader>oc :call g:BuildClang("Debug", "clean")<cr>
    au FileType cpp nnoremap <silent> <leader>oq :!qoden<cr>
    au FileType cpp nnoremap <silent> <leader>oO :call g:BuildClang("Release", "")<cr>
    au FileType cpp nnoremap <silent> <leader>oC :call g:BuildClang("Release", "clean")<cr>
    au FileType cpp nnoremap <silent> <leader>ov :call g:BuildClang("VisuLove", "dvisulove")<cr>
    au FileType cpp nnoremap <silent> <leader>ob :call g:BuildClang("VisuLove", "visuclean")<cr>

    " Autocommands for fswitch.vim
    au BufEnter *.cpp let b:fswitchdst = 'h'
    au BufEnter *.cpp let b:fswitchlocs = 'reg:/src/include/,reg:/src.*/include/,reg:|src|include/**|,../include'
    au BufEnter *.h let b:fswitchdst = 'cpp,c'
    au BufEnter *.h let b:fswitchlocs = 'reg:|include|src/**|,reg:|include.*|src/**|,../src'
    " }}} cpp "

    " All
    au QuickFixCmdPost * nested cwindow | redraw!

    " misc {{{ "

    au FileType c setlocal colorcolumn=79
    au BufNewFile,BufReadPost *.coffee setlocal foldmethod=indent shiftwidth=2 softtabstop=2 expandtab
    au BufWritePost,FileWritePost *.coffee silent make!
    au FileType gitcommit setlocal nolist cursorline cursorcolumn
    au FileType htmldjango setlocal expandtab shiftwidth=2 softtabstop=2
    au FileType javascript setlocal expandtab shiftwidth=2 softtabstop=2
    au FileType java setlocal noexpandtab shiftwidth=2 tabstop=2 softtabstop=0
    au FileType python setlocal expandtab shiftwidth=4 softtabstop=4 tabstop=8 
    au FileType yaml setlocal expandtab shiftwidth=2 softtabstop=2
    au FileType {make,gitconfig} set noexpandtab sw=4
    au FileType vim setlocal foldmethod=marker
    au FileType {md,tex,txt,rst,text} setlocal linebreak

    au BufWinEnter *.py call Riceoperators()
    au WinEnter *.py call Riceoperators()

    au TermOpen * tmap <buffer> jk <C-\><C-n>
    au TermOpen * tmap <buffer> kj <C-\><C-n>
    au TermOpen term://*:ranger* tunmap <buffer> jk
    au TermOpen term://*:ranger* tunmap <buffer> kj
    " }}} misc "

    augroup end

endif
" }}} Filetype specific settings "

" Extra syntax groups and keywords {{{ "
function! MyCppadd()
  syn keyword cMyItem contained TODO FIXME CLEAN PERF INFOSEC XOXO XXX
  syn cluster cCommentGroup add=cMyItem
  hi link cMyItem Todo
endfun
if has("autocmd")
augroup SyntaxKeywordGroup
    " Clear autocmds for this group
    autocmd!

    au Syntax cpp call MyCppadd()
augroup end
endif
" }}} Extra syntax groups and keywords "

" Backup settings {{{ "
if !has("win32") && !has("win64")
    set backup

    set undodir=/var/tmp/vi.recover.$USER/undo//     " undo files
    set backupdir=/var/tmp/vi.recover.$USER/backup// " backups
    set directory=/var/tmp/vi.recover.$USER/swap//   " swap files

    " Make those folders automatically if they don't already exist.
    if !isdirectory(expand(&undodir))
        call mkdir(expand(&undodir), "p", 0700)
    endif
    if !isdirectory(expand(&backupdir))
        call mkdir(expand(&backupdir), "p", 0700)
    endif
    if !isdirectory(expand(&directory))
        call mkdir(expand(&directory), "p", 0700)
    endif
end
" }}} Backup settings "

" Statusline settings {{{ "
set laststatus=2	" always show status line

function! FileEncoding()
    if &fileencoding == ''
        return "NONE"
    else
        return &fenc
    endif
endfunction

function! EolSetting()
    if &eol == 1
        return "↵"
    else
        return "⤓"
    endif
endfunction

set statusline=%<                                    " truncation point
set statusline+=%F                                   " full path to file
set statusline+=\ %m                                 " modified marker
set statusline+=%r                                   " read-only flag
set statusline+=%h                                   " help buffer flag
set statusline+=%w                                   " preview window flag
set statusline+=%{fugitive#statusline()}             " Shows git branch if file is in git repo
" set statusline+=\ %{LanguageClient#statusLine()}   " shows status of LSP Client's Server
set statusline+=\ %Y                                 " file type
set statusline+=\ %{FileEncoding()}                  " {FileEncoding} function defined above
set statusline+=\ %{&ff}                             " current value for the fileformat (abbreviated ff) setting
set statusline+=%{EolSetting()}                      " {EolSetting} function defined above
set statusline+=%=                                   " split point for left/rigth justification
set statusline+=\ %l/%L\,\ %c                        " line/total-lines, column
set statusline+=\ %p%%\                              " percentage through file (in lines)

" change status line colour if it is in insert mode
" if version >= 700
"     if has("autocmd")
"     augroup StatuslineColorGroup
"         " Clear autocmds for this group
"         autocmd!

"         au InsertEnter * hi StatusLine gui=NONE guifg=#FFFFFF guibg=#9D3569
"         au InsertLeave * hi StatusLine gui=NONE guifg=#d6d6d6 guibg=#602040
"     augroup end
"     endif
" endif
" }}} Statusline settings "

" Tabline settings {{{ "
function! MyTabLine()
  let s = '' " complete tabline goes here
  " loop through each tab page
  for t in range(tabpagenr('$'))

    " select the highlighting for the buffer names
    if t + 1 == tabpagenr()
      let s .= '%#TabLineSel#'
    else
      let s .= '%#TabLine#'
    endif

    " empty space
    let s .= ' '

    " set the tab page number (for mouse clicks)
    let s .= '%' . (t + 1) . 'T'

    " set page number string, with color
    if t + 1 == tabpagenr()
      let s .= '%#TabNumberSel#'
    else
      let s .= '%#TabNumber#'
    endif
    let s .= t + 1

    " select the highlighting for the buffer names again
    if t + 1 == tabpagenr()
      let s .= '%#TabLineSel#'
    else
      let s .= '%#TabLine#'
    endif

    " get buffer names and statuses
    let n = ''  "temp string for buffer names while we loop and check buftype
    let m = 0 " &modified counter
    let bc = len(tabpagebuflist(t + 1))  "counter to avoid last ' '
    " loop through each buffer in a tab
    for b in tabpagebuflist(t + 1)[:0]
      " Actually just the first buffer in the list for name
      " buffer types: quickfix gets a [Q], help gets [H]{base fname}
      " others get 1dir/2dir/3dir/fname shortened to 1/2/3/fname
      if getbufvar( b, "&buftype" ) == 'help'
        let n .= '[H]' . fnamemodify( bufname(b), ':t:s/.txt$//' )
      elseif getbufvar( b, "&buftype" ) == 'quickfix'
        let n .= '[Q]'
      else
        let n .= pathshorten(bufname(b))
        "let n .= bufname(b)
      endif
    endfor
    for b in tabpagebuflist(t + 1)
      " check and ++ tab's &modified count
      if getbufvar( b, "&modified" )
        let m += 1
      endif
    endfor
    " add buffer names
    if n == ''
      let s .= '[No Name]'
    else
      let s .= n
    endif
    " add modified label [n+] where n pages in tab are modified
    if m > 0
      "let s .= '[' . m . '+]'
      if t + 1 == tabpagenr()
        let s .= '%#TabModifiedSel#'
      else
        let s .= '%#TabModified#'
      endif
      let s.= '+'
      if t + 1 == tabpagenr()
        let s .= '%#TabLineSel#'
      else
        let s .= '%#TabLine#'
      endif
    endif
    " switch to no underlining and add final space to buffer list
    "let s .= '%#TabLineSel#' . ' '
    let s .= ' '
  endfor
  " after the last tab fill with TabLineFill and reset tab page nr
  let s .= '%#TabLineFill#%T'
  " right-align the label to close the current tab page
  if tabpagenr('$') > 1
    let s .= '%=%#TabLine#%999XX'
  endif
  return s
endfunction
set tabline=%!MyTabLine()
" }}} Tabline settings "

" Session information for :mksession {{{ "
set viminfo='1000,f1,<1000,:500,@500,/500,!
" '		Max number of previously edited files for which marks are
" 		remembered
" f		remember marks
" <		max number of lines saved per register
" :		max items in commandline history
" @		max items in input-line history to be saved
" /		max items in search pattern history
set ssop=blank,buffers,curdir,folds,help,options,tabpages,winsize,resize
" 		Enables saving and restoring
" blank		empty windows
" buffers	hidden and unloaded buffers
" curdir	remember the cwd
" folds		manually created folds, opened/closed folds and local fold opt
" help		the help window
" options	all options and mappings (also global vals for local opts)
" tabpages	all tab pages instead of only the current one
" winsize	window sizes (the windows inside vim)
" resize		size of the vim window, lines and columns
" }}} Session information for :mksession "

" Plugin settings {{{ "

" Fugitive {{{ "
" https://github.com/tpope/vim-fugitive
" Maps .. to go up one level from fugitive blob and tree views
if has("autocmd")
augroup FugitiveGroup
    " Clear autocmds for this group
    autocmd!

    autocmd User fugitive
      \ if fugitive#buffer().type() =~# '^\%(tree\|blob\)$' |
      \   nnoremap <buffer> .. :edit %:h<CR> |
      \ endif

    " Automatically delete hidden fugitive buffers
    autocmd BufReadPost fugitive://* set bufhidden=delete
augroup end
endif

" }}} Fugitive "

" gitgutter {{{ "
" let g:gitgutter_map_keys = 0
" 
" " nmap <leader>ht <Plug>GitGutterSignsToggle
" " nmap <leader>hp <Plug>GitGutterPreviewHunk
" " nmap <leader>hs <Plug>GitGutterStageHunk
" " nmap <leader>hu <Plug>GitGutterUndoHunk
" nnoremap <leader>ht :<c-u>GitGutterSignsToggle<cr>
" nnoremap <leader>hp :<c-u>GitGutterPreviewHunk<cr>
" nnoremap <leader>hs :<c-u>GitGutterStageHunk<cr>
" nnoremap <leader>hu :<c-u>GitGutterUndoHunk<cr>
" nmap [h <Plug>GitGutterPrevHunk
" nmap ]h <Plug>GitGutterNextHunk
" omap ih <Plug>GitGutterTextObjectInnerPending
" omap ah <Plug>GitGutterTextObjectOuterPending
" xmap ih <Plug>GitGutterTextObjectInnerVisual
" xmap ah <Plug>GitGutterTextObjectOuterVisual
" }}} gitgutter "

" vim-space {{{ "
"" http://github.com/jfelchner/vim-space
""
let g:space_no_buffers = 1
let g:space_no_tabs = 1
" }}} vim-space "

" tsuquyomi {{{ "
"" https://github.com/Quramy/tsuquyomi
""
let g:tsuquyomi_disable_quickfix = 1 " Use syntastic's shizzle instead
let g:syntastic_typescript_checkers = ['tsuquyomi']

let g:tsuquyomi_single_quote_import = 1

let g:tsuquyomi_completion_detail = 1
" let g:tsuquyomi_completion_preview = 1
" }}} tsuquyomi "

" Gist {{{ "
"" https://github.com/mattn/gist-vim
""
let g:gist_clip_command = 'xsel --clipboard -i'
let g:gist_detect_filetype = 1
" }}} Gist "

" Unite {{{ "
" Fuzzy match by default
call unite#filters#matcher_default#use(['matcher_fuzzy'])
call unite#filters#sorter_default#use(['sorter_rank'])

" Fuzzy matching for plugins not using matcher_default as filter
call unite#custom#source('outline,line,grep,session', 'matchers', ['matcher_fuzzy'])

" Ignore some things
" KEEP THESE IN SYNC WITH WILDIGNORE!
" Need to escape dots in the patterns!
call unite#custom#source('file_rec,file_rec/async,file_mru,file,grep',
            \ 'ignore_pattern', join([
            \ '\.swp', '\.swo', '\~$',
            \ '\.git/', '\.svn/', '\.hg/',
            \ '^tags$', '\.taghl$',
            \ '\.ropeproject/', '\.pbxproj$', '\.xcodeproj', '\.vcproj', 
            \ 'node_modules/', 'bower_components/', 'typings/', 'libs/', 'log/', 'tmp/', 'obj/',
            \ '/vendor/gems/', '/vendor/cache/', '\.bundle/', '\.sass-cache/',
            \ '/tmp/cache/assets/.*/sprockets/', '/tmp/cache/assets/.*/sass/',
            \ 'thirdparty/', 'Debug/', 'Release/', 'build/', 'dist/',
            \ 'web/static/components/', 'web/static/external/', 'web/static/images/',
            \ '\.pyc$', 'pb2\.py$', '\.class$', '\.jar$', '\.min\.js$',
            \ '\.jpg$', '\.jpeg$', '\.bmp$', '\.png$', '\.gif$',
            \ '\.o$', '\.out$', '\.obj$', '\.rbc$', '\.rbo$', '\.gem$',
            \ '\.zip$', '\.tar\.gz$', '\.tar\.bz2$', '\.rar$', '\.tar\.xz$'
            \ ], '\|'))

" call unite#custom#source('file_rec,file_rec/async,file_mru,file,grep', 'ignore_globs',
    " \ split(&wildignore, ','))

let g:unite_source_rec_max_cache_files = 0
call unite#custom#source('file_rec,file_rec/async,file_mru,file,buffer,grep',
            \ 'max_candidates', 0)

" Keep track of yanks
let g:unite_source_history_yank_enable = 1
" Prettier prompt
call unite#custom#profile('default', 'context', {
    \   'prompt': '» ',
    \   'start_insert': 1,
    \   'update_time': 200,
    \   'cursor_line_highlight': 'UniteSelectedLine',
    \   'direction': 'botright',
    \   'prompt_direction': 'top',
    \ })
" Autosave sessions for unite-sessions
let g:unite_source_session_enable_auto_save = 1
" Non-ugly colors for selected item, requires you to set 'hi UnitedSelectedLine'
let g:unite_cursor_line_highlight = "UniteSelectedLine"
" Set to some better time formats
let g:unite_source_buffer_time_format = "%Y-%m-%d  %H:%M:%S  "
let g:unite_source_file_mru_time_format = "%Y-%m-%d  %H:%M:%S  "

" Use ag or ack as grep command if possible
if executable('rg')
  let g:unite_source_grep_command = 'rg'
  let g:unite_source_grep_default_opts = '-S --hidden --no-heading --vimgrep --iglob "!*.bcm" --iglob "!package-lock.json" --iglob "!yarn.lock"'
  let g:unite_source_grep_recursive_opt = ''
elseif executable('ag')
  let g:unite_source_grep_command = 'ag'
  let g:unite_source_grep_default_opts = '--nocolor --nogroup --hidden --ignore-case --ignore tags'
  let g:unite_source_grep_recursive_opt = ''
elseif executable('ack-grep')
  let g:unite_source_grep_command = 'ack-grep'
  let g:unite_source_grep_default_opts =
              \ '--no-heading --no-color -a -H'
  let g:unite_source_grep_recursive_opt = ''
endif

function! g:DoUniteFuzzy()
    call unite#custom#source('file_rec/async,file/new', 'sorters', 'sorter_rank')
    call unite#custom#source('file_rec/async,file/new', 'converters', 'converter_relative_word')
    call unite#custom#source('file_rec/async,file/new', 'matchers', 'matcher_fuzzy')
    exec "Unite -buffer-name=files file_rec/async file/new"
endfunction
function! g:DoUniteNonFuzzy()
    call unite#custom#source('file_rec/async,file/new', 'sorters', 'sorter_nothing')
    call unite#custom#source('file_rec/async,file/new', 'converters', 'converter_relative_word')
    call unite#custom#source('file_rec/async,file/new', 'matchers', 'matcher_glob')
    exec "Unite -buffer-name=files file_rec/async file/new"
endfunction
function! g:DoUniteFuzzyQuickfix()
    call unite#custom#source('quickfix', 'sorters', 'sorter_rank')
    call unite#custom#source('quickfix', 'matchers', 'matcher_fuzzy')
    exec "Unite -buffer-name=quickfix quickfix"
endfunction
function! g:DoUniteNonFuzzyQuickfix()
    call unite#custom#source('quickfix', 'sorters', 'sorter_nothing')
    call unite#custom#source('quickfix', 'matchers', 'matcher_glob')
    exec "Unite -buffer-name=quickfix quickfix"
endfunction
function! g:DoUniteFuzzyLine()
    call unite#custom#source('line', 'sorters', 'sorter_rank')
    call unite#custom#source('line', 'matchers', 'matcher_fuzzy')
    exec "Unite -buffer-name=line line"
endfunction
function! g:DoUniteNonFuzzyLine()
    call unite#custom#source('line', 'sorters', 'sorter_nothing')
    call unite#custom#source('line', 'matchers', 'matcher_glob')
    exec "Unite -buffer-name=line line"
endfunction
function! UltiSnipsCallUnite()
    Unite -immediately -no-empty -vertical -buffer-name=ultisnips ultisnips
    return ''
endfunction

" Bindings
" inoremap <silent><leader>l<tab> <C-R>=(pumvisible()? "\<LT>C-E>":"")<CR><C-R>=UltiSnipsCallUnite()<CR>
" nnoremap <silent><leader>l<tab> a<C-R>=(pumvisible()? "\<LT>C-E>":"")<CR><C-R>=UltiSnipsCallUnite()<CR>
nnoremap <silent><leader>lr :call g:DoUniteFuzzy()<CR>
nnoremap <silent><leader>lR :call g:DoUniteNonFuzzy()<CR>
nnoremap <silent><leader>lq :call g:DoUniteFuzzyQuickfix()<CR>
nnoremap <silent><leader>lQ :call g:DoUniteNonFuzzyQuickfix()<CR>
nnoremap <silent><leader>ll :call g:DoUniteFuzzyLine()<CR>
nnoremap <silent><leader>lL :call g:DoUniteNonFuzzyLine()<CR>
nnoremap <silent><leader>le :<C-u>Unite -buffer-name=files file_mru bookmark<CR>
nnoremap <silent><leader>lE :<C-u>Unite -buffer-name=files file_mru bookmark file_rec/async file/new<CR>
nnoremap <silent><leader>lb :<C-u>Unite -buffer-name=buffers buffer<CR>
nnoremap <silent><leader>lB :<C-u>Unite -buffer-name=buffers buffer_tab<CR>
nnoremap <silent><leader>ly :<C-u>Unite -buffer-name=yanks history/yank<CR>
nnoremap <silent><leader>lc :<C-u>Unite -buffer-name=changes change<CR>
nnoremap <silent><leader>lj :<C-u>Unite -buffer-name=jumps jump<CR>
nnoremap <silent><leader>lf :<C-u>Unite -buffer-name=jumps jump<CR>
nnoremap <silent><leader>l; :<C-u>Unite -buffer-name=commands history/command<CR>
nnoremap <silent><leader>l/ :<C-u>Unite -buffer-name=commands history/search<CR>
nnoremap <silent><leader>lo :<C-u>Unite -buffer-name=outline outline<CR>
nnoremap <silent><leader>la :<C-u>Unite -buffer-name=outline -vertical outline<CR>
nnoremap <silent><leader>lw :<C-u>Unite -buffer-name=location_list location_list<CR>
nnoremap <silent><leader>l* :<C-u>UniteWithCursorWord -buffer-name=line line<CR>
nnoremap <silent><leader>lg :<C-u>Unite -buffer-name=grep grep<CR>
nnoremap <silent><leader>lG "zyiw:<C-u>Unite -buffer-name=grepword grep<CR><CR><C-R>z<CR>
vnoremap <silent><leader>lG "zy:<C-u>Unite -buffer-name=grepword grep<CR><CR><C-R>z<CR>
nnoremap <silent><leader>ls :<C-u>Unite session<CR>
nnoremap <silent><leader>lt :<C-u>Unite -buffer-name=tags tag<CR>
nnoremap <silent><leader>lT :<C-u>Unite -buffer-name=tagfiles tag/file<CR>
nnoremap <silent><leader>li :<C-u>Unite -buffer-name=autotags tag/include<CR>
nnoremap <silent><leader>ld :<C-u>Unite -buffer-name=change-cwd -default-action=lcd directory_mru directory<CR>
nnoremap <silent><leader>l, :<C-u>UniteResume<CR>
nnoremap <silent><leader>lv :<C-u>UniteResume<CR>
nnoremap <silent><leader>lV :<C-u>UniteResume

nnoremap <leader>lS :<C-u>UniteSessionSave

nnoremap <silent>[R :<C-u>UnitePrevious<cr>
nnoremap <silent>]R :<C-u>UniteNext<cr>

function! s:unite_my_settings()
  "Don't add parens to my filters
  let b:delimitMate_autoclose = 0

  "Keymaps inside the unite split
  nmap <buffer> <nowait> <leader>d <Plug>(unite_exit)
  nmap <buffer> <nowait> <C-c> <Plug>(unite_exit)
  imap <buffer> <nowait> <C-c> <Plug>(unite_exit)

  nnoremap <buffer> <C-n> <Plug>(unite_select_next_line)
  nnoremap <buffer> <C-p> <Plug>(unite_select_previous_line)

  nnoremap <buffer> <Up> 3<c-y>
  nnoremap <buffer> <Down> 3<c-e>
  inoremap <buffer> <Up> <esc>3<c-y>
  inoremap <buffer> <Down> <esc>3<c-e>

  inoremap <silent><buffer><expr> <C-j> unite#do_action('split')
  nnoremap <silent><buffer><expr> <C-j> unite#do_action('split')
  inoremap <silent><buffer><expr> <C-k> unite#do_action('vsplit')
  nnoremap <silent><buffer><expr> <C-k> unite#do_action('vsplit')
endfunction

if has("autocmd")
augroup UniteSettingsGroup
    " Clear autocmds for this group
    autocmd!

    autocmd FileType unite call s:unite_my_settings()
augroup end
endif

" }}} Unite "

" Denite {{{ "

" Denite config {{{ "

" Keymaps {{{ "
autocmd FileType denite call s:denite_my_settings()
function! s:denite_my_settings() abort
    nnoremap <silent><buffer><expr> <CR>
                \ denite#do_map('do_action')
    nnoremap <silent><buffer><expr> d
                \ denite#do_map('do_action', 'delete')
    nnoremap <silent><buffer><expr> p
                \ denite#do_map('do_action', 'preview')
    nnoremap <silent><buffer><expr> <C-Space>
                \ denite#do_map('quit')
    nnoremap <silent><buffer><expr> q
                \ denite#do_map('quit')
    nnoremap <silent><buffer><expr> i
                \ denite#do_map('open_filter_buffer')
    nnoremap <silent><buffer><expr> I
                \ denite#do_map('open_filter_buffer')
    nnoremap <silent><buffer><expr> a
                \ denite#do_map('open_filter_buffer')
    nnoremap <silent><buffer><expr> A
                \ denite#do_map('open_filter_buffer')
    nnoremap <silent><buffer><expr> <esc>
                \ denite#do_map('open_filter_buffer')
    nnoremap <silent><buffer><expr> <Space>
                \ denite#do_map('toggle_select').'j'
endfunction

autocmd FileType denite-filter call s:denite_filter_my_settings()
function! s:denite_filter_my_settings() abort
    call deoplete#custom#buffer_option('auto_complete', v:false)
    imap <silent><buffer> <esc> <Plug>(denite_filter_quit)
    imap <silent><buffer> <c-o> <Plug>(denite_filter_quit)
    inoremap <silent><buffer> <C-n>
                \ <Esc><C-w>p:call cursor(line('.')+1,0)<CR><C-w>pA
    inoremap <silent><buffer> <C-p>
                \ <Esc><C-w>p:call cursor(line('.')-1,0)<CR><C-w>pA
    inoremap <silent><buffer><expr> <C-Space>
                \ denite#do_map('quit')
    inoremap <silent><buffer><expr> <CR>
                \ denite#do_map('do_action')
    inoremap <silent><buffer><expr> <C-t>
                \ denite#do_map('do_action', 'tabopen')
    inoremap <silent><buffer><expr> <C-k>
                \ denite#do_map('do_action', 'vsplit')
    inoremap <silent><buffer><expr> <C-j>
                \ denite#do_map('do_action', 'split')
endfunction
" }}} Keymaps "

" Default configs {{{ "
"   auto_resize             - Auto resize the Denite window height automatically.
"   prompt                  - Customize denite prompt
"   direction               - Specify Denite window direction as directly below current pane
"   winminheight            - Specify min height for Denite window
"   highlight_mode_insert   - Specify h1-CursorLine in insert mode
"   prompt_highlight        - Specify color of prompt
"   highlight_matched_char  - Matched characters highlight
"   highlight_matched_range - matched range highlight
let s:denite_options = {'default' : {
            \ 'split': 'horizontal',
            \ 'start_filter': 1,
            \ 'auto_resize': 1,
            \ 'source_names': 'short',
            \ 'prompt': '> ',
            \ 'winrow': 1,
            \ 'vertical_preview': 0,
            \ 'winheight': 5000,
            \ 'maxcandidates': 5000,
            \ 'filter_split_direction': 'botright',
            \ }}

" Loop through denite options and enable them
function! s:profile(opts) abort
  for l:fname in keys(a:opts)
    for l:dopt in keys(a:opts[l:fname])
      call denite#custom#option(l:fname, l:dopt, a:opts[l:fname][l:dopt])
    endfor
  endfor
endfunction

call s:profile(s:denite_options)
" }}} Default configs "

" Denite grep ripgrep config {{{ "
" if executable('fd')
"     call denite#custom#var('file/rec', 'command',
"             \ ['fd', '.'])
" endif
if executable('rg')
    call denite#custom#var('file/rec', 'command',
            \ ['rg', '--files', '--color', 'never'])

    call denite#custom#var('grep', 'command', ['rg'])
    call denite#custom#var('grep', 'default_opts',
                \ ['--vimgrep', '--no-heading', '--color', 'never', '--smart-case'])
    call denite#custom#var('grep', 'recursive_opts', [])
    call denite#custom#var('grep', 'pattern_opt', ['--regexp'])
    call denite#custom#var('grep', 'separator', ['--'])
    call denite#custom#var('grep', 'final_opts', [])
endif
" }}} Denite grep ripgrep config "

call denite#custom#option('_', 'highlight_mode_insert', 'UniteSelectedLine')

" Denite mappings {{{ "
nnoremap <silent><leader>a: :<c-u>Denite command<cr>
nnoremap <silent><leader>a; :<c-u>Denite command_history<cr>
nnoremap <silent><leader>aG :<c-u>Denite grep:::`expand('<cword>')`<cr>
vnoremap <silent><leader>aG "zy:<c-u>Denite grep:::`@z`<cr>
nnoremap <silent><leader>aa :<c-u>Denite -split=vertical outline<cr>
nnoremap <silent><leader>aA :<c-u>Denite -split=vertical unite:outline<cr>
nnoremap <silent><leader>ab :<c-u>Denite buffer<cr>
nnoremap <silent><leader>ac :<c-u>Denite change<cr>
nnoremap <silent><leader>ad :<c-u>Denite directory_rec<cr>
nnoremap <silent><leader>ae :<c-u>Denite file_mru<cr>
nnoremap <silent><leader>ag :<c-u>Denite grep<cr>
nnoremap <silent><leader>ai :<c-u>Denite grep:::!<cr>
nnoremap <silent><leader>ah :<c-u>Denite help<cr>
nnoremap <silent><leader>aJ :<c-u>Denite jump<cr>
nnoremap <silent><leader>al :<c-u>Denite line<cr>
nnoremap <silent><leader>aL :<c-u>Denite -matchers=matcher_fuzzy line<cr>
nnoremap <silent><leader>ar :<c-u>Denite -winheight=15 file/rec<cr>
nnoremap <silent><leader>aR :<c-u>DeniteBufferDir -winheight=15 file/rec<cr>
nnoremap <silent><leader>at :<c-u>Denite tag<cr>
nnoremap <silent><leader>av :<c-u>Denite -resume<cr>
nnoremap <silent><leader>ay :<c-u>Denite register<cr>
nnoremap <silent><leader>aY :<c-u>Denite unite:history/yank<cr>
nnoremap <silent><leader>aq :<c-u>Denite quickfix<cr>
nnoremap <silent><leader>aQ :<c-u>Denite location_list<cr>
nnoremap <silent><leader>a/ :<c-u>Denite history:search<cr>
nnoremap <silent><leader>a<tab> :<c-u>Denite -split=vertical unite:ultisnips<cr>
nnoremap <silent><leader>a<space> :<c-u>Denite -split=floating contextMenu<cr>
nnoremap <silent><leader>ajr :<c-u>Denite -split=floating contextMenu<cr>

nnoremap <silent>]r :<c-u>Denite -resume -cursor-pos=+1 -immediately<cr>
nnoremap <silent>[r :<c-u>Denite -resume -cursor-pos=-1 -immediately<cr>

" Bindings
" TODO nnoremap <silent><leader>ay :<c-u>Denite yank<cr>
" TODO handle colons in selected text, the following doesn't quite work
" vnoremap <silent><leader>aG "zy:<c-u>Denite grep:::`substitute(@z, ":", "\\:", "")`<cr>
" }}} Denite mappings "

" }}} Denite config "

" fruzzy {{{ "
let g:fruzzy#usenative = 1
call denite#custom#source('_', 'matchers', ['matcher/fruzzy'])
" }}} fruzzy "
" }}} Denite "

" Rainbow-Parentheses-Improved-and2 {{{ "
"" Rainbow-Parentheses-Improved-and2 settings
"" http://github.com/vim-scripts/Rainbow-Parentheses-Improved-and2
""
" These are so ugly
"let g:rainbow_ctermfgs = [184, 39, 170, 162, 154, 9, 10, 11, 13, 14, 15]
" These are alright
"let g:rainbow_guifgs = ['#ffffff', '#000000']
    "\   'guifgs': ['#8E8EBE', '#8E8E8E', '#BE8EBE', '#BEBE8E', '#8EBE8E', '#BE8E8E'],
let g:rainbow_conf = {
    \   'guifgs': ['#A77990', '#8DC4C4', '#C6ACC6', '#ADBCA0', '#A2B1C1', '#C6A0B3', '#98A7B7', '#7B907C', '#B7AB9B', '#96C1AC', '#79A9A9', '#96838D', '#C6A890'],
    \   'ctermfgs': ['darkgray', 'darkblue', 'darkmagenta', 'darkcyan'],
    \   'operators': '_,_',
    \   'parentheses': ['start=/(/ end=/)/ fold', 'start=/\[/ end=/\]/ fold', 'start=/{/ end=/}/ fold'],
    \   'separately': {
    \       '*': {},
    \       'lisp': {
    \           'guifgs': ['royalblue3', 'darkorange3', 'seagreen3', 'firebrick', 'darkorchid3'],
    \           'ctermfgs': ['darkgray', 'darkblue', 'darkmagenta', 'darkcyan', 'darkred', 'darkgreen'],
    \       },
    \       'vim': {
    \           'parentheses': [['fu\w* \s*.*)','endfu\w*'], ['for','endfor'], ['while', 'endwhile'], ['if','_elseif\|else_','endif'], ['(',')'], ['\[','\]'], ['{','}']],
    \       },
    \       'tex': {
    \           'parentheses': [['(',')'], ['\[','\]'], ['\\begin{.*}','\\end{.*}']],
    \       },
    \       'css': 0,
    \       'xml': {
    \           'parentheses': [['\v\<\z([-_:a-zA-Z0-9]+)(\s+[-_:a-zA-Z0-9]+(\=("[^"]*"|'."'".'[^'."'".']*'."'".'))?)*\>','</\z1>']],
    \       },
    \       'xhtml': {
    \           'parentheses': [['\v\<\z([-_:a-zA-Z0-9]+)(\s+[-_:a-zA-Z0-9]+(\=("[^"]*"|'."'".'[^'."'".']*'."'".'))?)*\>','</\z1>']],
    \       },
    \       'djangohtml': {
    \           'guifgs': [],
    \           'ctermfgs': [],
    \           'parantheses': [],
    \           'operators': []},
    \       'html': {
    \           'parentheses': [['\v\<((area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)[ >])@!\z([-_:a-zA-Z0-9]+)(\s+[-_:a-zA-Z0-9]+(\=("[^"]*"|'."'".'[^'."'".']*'."'".'|[^ '."'".'"><=`]*))?)*\>','</\z1>']],
    \       },
    \   }
    \}
let g:rainbow_active = 1
let g:rainbow_operators = 1
" }}} Rainbow-Parentheses-Improved-and2 "

" vim-togglelist {{{ "
" https://github.com/xaimus/vim-togglelist
" nnoremap <silent> <leader>A :Ltoggle<cr>
nnoremap <silent> <leader>Q :Ctoggle<cr>
" }}} vim-togglelist "

" jedi-vim {{{ "
" play nice with neocomplcache
let g:jedi#auto_initialization = 1
let g:jedi#auto_vim_configuration = 0
let g:jedi#popup_on_dot = 0
let g:jedi#completions_enabled = 0

let g:jedi#goto_assignments_command = "<leader>jg"
let g:jedi#goto_definitions_command = "<leader>jd"
let g:jedi#documentation_command    = "K"
let g:jedi#usages_command           = "<leader>ju"
let g:jedi#completions_command      = "<leader>jc"
let g:jedi#rename_command           = "<leader>jr"
let g:jedi#show_call_signatures     = "0"

if has("autocmd")
augroup JediGroup
    " Clear autocmds for this group
    autocmd!

    autocmd FileType python setlocal omnifunc=jedi#completions
    autocmd FileType python let b:did_ftplugin = 1
augroup end
endif
" }}} jedi-vim "

" " vim-sparkup {{{ "
" let g:sparkupExecuteMapping = '<leader>V'
" let g:sparkupNextMapping = '<leader>B'
" " }}} vim-sparkup "

" UltiSnips {{{ "
let g:UltiSnipsEditSplit = 'horizontal'
let g:UltiSnipsExpandTrigger = '<c-j>'
let g:UltiSnipsJumpForwardTrigger = '<c-j>'
let g:UltiSnipsJumpBackwardTrigger = '<c-e>'
" let g:UltiSnipsUsePythonVersion = 2
" }}} UltiSnips "

" Misc {{{ "
let g:gist_detect_filetype = 1

let g:maximizer_set_default_mapping = 0

let g:fontzoom_no_default_key_mappings = 1

if ! exists('g:TagHighlightSettings')
    let g:TagHighlightSettings = {}
endif
" let g:TagHighlightSettings['TagFileName'] = '.git/tags'

let g:undotree_SetFocusWhenToggle = 1

let g:NERDSpaceDelims = 1
let g:NERDCompactSexyComs = 1

let g:delimitMate_matchpairs = "(:),[:],{:},<:>"
let g:delimitMate_quotes = "\" ' `"

" far {{{ "
" if has('nvim')
"     let g:far#source = 'rgnvim'
" else
"     let g:far#source = 'rg'
" end
" }}} far "

" }}} Misc "

" incsearch.vim {{{ "

map /  <Plug>(incsearch-forward)
map ?  <Plug>(incsearch-backward)
map g/ <Plug>(incsearch-stay)

" }}} incsearch.vim "

" clang_complete {{{ "
" let g:clang_complete_loaded = 1 " Don't load clang_complete
let g:clang_complete_auto = 0
let g:clang_auto_select = 0
let g:clang_snippets_engine = 'ultisnips'
let g:clang_snippets = 1
let g:clang_use_library = 1
let g:clang_complete_macros = 1
"let g:clang_user_options = '|| exit 0'

" For OSX
let s:clang_library_path='/Library/Developer/CommandLineTools/usr/lib'
if isdirectory(s:clang_library_path)
    let g:clang_library_path=s:clang_library_path
endif

" }}} clang_complete "

" vim-indent-guides {{{ "
let g:indent_guides_auto_colors = 0
let g:indent_guides_guide_size = 0
let g:indent_guides_start_level = 2
let g:indent_guides_enable_on_vim_startup = 1
let g:indent_guides_exclude_filetypes = ['help', 'unite', 'man']
" }}} vim-indent-guides "

" haskellmode-vim {{{ "
let g:haddock_browser = "/usr/bin/google-chrome"
let g:ghc = "/usr/bin/ghc"
" }}} haskellmode-vim "

" switch.vim {{{ "
" These switches apply to all filetypes
let g:switch_custom_definitions =
    \ [
    \   ['&&', '||'],
    \   {
    \     '\CTrue':  'False',
    \     '\CFalse': 'True',
    \   },
    \   {
    \     '\Ctrue':  'false',
    \     '\Cfalse': 'true',
    \   },
    \   ['width', 'height'],
    \   ['left', 'right'],
    \   ['top', 'bottom'],
    \   ['above', 'below'],
    \   ['let', 'const'],
    \   ['GET', 'POST'],
    \   ['public', 'private'],
    \   ['null', 'undefined'],
    \ ]
if has("autocmd")
augroup SwitchVimFtGroups
    " Clear autocmds for this group
    autocmd!

    autocmd FileType cpp let b:switch_custom_definitions =
        \ [
        \   g:switch_builtins.cpp_pointer,
        \
        \   {
        \     ' & ': ' * ',
        \     ' \* ': ' & '
        \   },
        \
        \   g:switch_builtins.rspec_should,
        \ ]
augroup end
endif
" }}} switch.vim "

" localvimrc {{{ "
" let g:localvimrc_sandbox = 0
let g:localvimrc_persistent = 2
" }}} localvimrc "

" vim-sneak {{{ "
nmap gm <Plug>Sneak_s
nmap gM <Plug>Sneak_S
xmap gm <Plug>Sneak_s
xmap gM <Plug>Sneak_S
omap gm <Plug>Sneak_s
omap gM <Plug>Sneak_S

map gl <Plug>SneakNext
map gh <Plug>SneakPrevious
" }}} vim-sneak "

" zeavim {{{ "
nmap <leader>ff <Plug>Zeavim
vmap <leader>ff <Plug>ZVVisSelection
nmap <leader>f <Plug>ZVMotion
nmap <leader>F <Plug>ZVKeyDocset

let g:zv_file_types = {
            \	'^(G|g)ulpfile\.'       : 'javascript,Lo-Dash,jQuery,gulp',
            \	'typescript'            : 'javascript,Lo-Dash,jQuery,typescript',
            \	'javascript'            : 'javascript,Lo-Dash,jQuery',
            \ }
" }}} zeavim "

" rust, racer {{{ "
let g:rust_conceal = 1
let g:rust_fold = 1
let g:rustfmt_command = "$HOME/.cargo/bin/rustfmt"
let g:rustfmt_autosave = 0
" let g:racer_cmd = "$HOME/.cargo/bin/racer"
" let $RUST_SRC_PATH = "$HOME/.multirust/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src"
" }}} rust, racer "

" vimwiki / taskwiki / taskwarrior {{{ "
let g:task_rc_override     = 'rc.defaultwidth=999'
let g:taskwiki_sort_order = 'status+,urgency-,end+,pri-,project+'
let g:taskwiki_source_tw_colors = 'yes'

let g:vimwiki_dir_link = 'index'
let g:vimwiki_auto_chdir = 1

let personalwiki = {}
let personalwiki.path = '~/Storage/documents/vim_wiki'
let personalwiki.index = 'index'

let cmaowiki = {}
let cmaowiki.path = '~/Storage/documents/codemao_wiki'
let cmaowiki.index = 'index'

let g:vimwiki_list = [personalwiki, cmaowiki]
" }}} vimwiki / taskwiki / taskwarrior " 

" ALE {{{ "
let g:ale_fixers = {
\   'typescript': [
\       'tslint',
\   ],
\}

" let g:ale_pattern_options = {
" \   'fugitive:.*': {
" \      'ale_enabled': 0,
" \   },
" \}

" }}} ALE "

" ranger.vim {{{ "
let g:ranger_map_keys = 0
nnoremap <silent> <leader>r<space> :<C-U>RangerCurrentFile<cr>
nnoremap <silent> <leader>rr :<C-U>RangerWorkingDirectory<cr>
nnoremap <silent> <leader>rt :<c-u>tabnew<cr>:RangerCurrentFile<cr>
nnoremap <silent> <leader>rj :<c-u>split<cr><c-w>j:RangerCurrentFile<cr>
nnoremap <silent> <leader>rk :<c-u>split<cr>:RangerCurrentFile<cr>
nnoremap <silent> <leader>rh :<c-u>vsplit<cr>:RangerCurrentFile<cr>
nnoremap <silent> <leader>rl :<c-u>vsplit<cr><c-w>l:RangerCurrentFile<cr>
nnoremap <silent> <leader>rT :<c-u>tabnew<cr>:RangerWorkingDirectory<cr>
nnoremap <silent> <leader>rJ :<c-u>split<cr><c-w>j:RangerWorkingDirectory<cr>
nnoremap <silent> <leader>rK :<c-u>split<cr>:RangerWorkingDirectory<cr>
nnoremap <silent> <leader>rH :<c-u>vsplit<cr>:RangerWorkingDirectory<cr>
nnoremap <silent> <leader>rL :<c-u>vsplit<cr><c-w>l:RangerWorkingDirectory<cr>
" }}} ranger.vim "

" }}} Plugin settings "

" VisualSearch {{{ "
vnoremap <silent> * :call VisualSearch('f')<CR>
vnoremap <silent> # :call VisualSearch('b')<CR>

function! CmdLine(str)
    exe "menu Foo.Bar :" . a:str
    emenu Foo.Bar
    unmenu Foo
endfunction

" From an idea by Michael Naumann
function! VisualSearch(direction) range
    let l:saved_reg = @"
    execute "normal! vgvy"

    let l:pattern = escape(@", '\\/.*$^~[]')
    let l:pattern = substitute(l:pattern, "\n$", "", "")

    if a:direction == 'b'
        execute "normal ?" . l:pattern . "^M"
    elseif a:direction == 'gv'
        call CmdLine("vimgrep " . '/'. l:pattern . '/' . ' **/*.')
    elseif a:direction == 'f'
        execute "normal /" . l:pattern . "^M"
    endif

    let @/ = l:pattern
    let @" = l:saved_reg
endfunction
" }}} VisualSearch "

" Highlight Word {{{ "
"
" This mini-plugin provides a few mappings for highlighting words temporarily.
"
" Sometimes you're looking at a hairy piece of code and would like a certain
" word or two to stand out temporarily.  You can search for it, but that only
" gives you one color of highlighting.  Now you can use <leader>N where N is
" a number from 1-6 to highlight the current word in a specific color.
"
" From Steve Losh @ https://bitbucket.org/sjl/dotfiles/src/tip/vim/vimrc

function! HiInterestingWord(n)
    " Save our location.
    normal! mz

    " Yank the current word into the z register.
    normal! "zyiw

    " Calculate an arbitrary match ID.  Hopefully nothing else is using it.
    let mid = 86750 + a:n

    " Clear existing matches, but don't worry if they don't exist.
    silent! call matchdelete(mid)

    " Construct a literal pattern that has to match at boundaries.
    let pat = '\V\<' . escape(@z, '\') . '\>'

    " Actually match the words.
    call matchadd("InterestingWord" . a:n, pat, 1, mid)

    " Move back to our original location.
    normal! `z
endfunction

nnoremap <silent> <leader>1 :call HiInterestingWord(1)<cr>
nnoremap <silent> <leader>2 :call HiInterestingWord(2)<cr>
nnoremap <silent> <leader>3 :call HiInterestingWord(3)<cr>
nnoremap <silent> <leader>4 :call HiInterestingWord(4)<cr>
nnoremap <silent> <leader>5 :call HiInterestingWord(5)<cr>
nnoremap <silent> <leader>6 :call HiInterestingWord(6)<cr>

" Create highlight definitions such as:
" hi def InterestingWord1 guifg=#000000 ctermfg=16 guibg=#ffa724 ctermbg=214
" hi def InterestingWord2 guifg=#000000 ctermfg=16 guibg=#aeee00 ctermbg=154
" }}} Highlight Word "

" Uppercase word mapping {{{ "
"
" This mapping allows you to press <c-u> in insert mode to convert the current
" word to uppercase.  It's handy when you're writing names of constants and
" don't want to use Capslock.
"
" To use it you type the name of the constant in lowercase.  While your
" cursor is at the end of the word, press <c-u> to uppercase it, and then
" continue happily on your way:
"
"                            cursor
"                            v
"     max_connections_allowed|
"     <c-u>
"     MAX_CONNECTIONS_ALLOWED|
"                            ^
"                            cursor
"
" It works by exiting out of insert mode, recording the current cursor location
" in the z mark, using gUiw to uppercase inside the current word, moving back to
" the z mark, and entering insert mode again.
"
" Note that this will overwrite the contents of the z mark.  I never use it, but
" if you do you'll probably want to use another mark.
inoremap <c-b> <esc>mzgUiw`za
" }}} Uppercase word mapping "

" Visual-linewise macro playback aka visual-at.vim {{{ "
" https://github.com/stoeffel/.dotfiles/blob/master/vim/visual-at.vim

function! ExecuteMacroOverVisualRange()
    echo "@".getcmdline()
    execute ":'<,'>normal @".nr2char(getchar())
endfunction

xnoremap @ :<C-u>call ExecuteMacroOverVisualRange()<CR>

" }}} Visual-linewise macro playback " 

" Keymaps {{{ "

" ToggleColorColumn() {{{ "

" Toggle colorcolumn TODO make this save previous value
" instead of using 79 all the time.
function! g:ToggleColorColumn()
    if &colorcolumn != ''
        setlocal colorcolumn&
    else
        setlocal colorcolumn=79
    endif
endfunction

function! g:ToggleColorScheme()
    if g:colors_name == 'liquorice' || g:colors_name == 'liquorice-approx'
        let l:theme = 'proton'
    else
        let l:theme = 'liquorice'
    endif

    echo ""

    if has("gui_running") || has('nvim')
        execute "colorscheme " . l:theme
    else
        execute "colorscheme " . l:theme . '-approx'
    end
endfunction

" }}} ToggleColorColumn() "

" Map the leader keys
let mapleader="\\"
" let maplocalleader="\\\\"
let maplocalleader=","

" j/k linewise unless count is used
nnoremap <expr> k (v:count == 0 ? 'gk' : 'k')
nnoremap <expr> j (v:count == 0 ? 'gj' : 'j')

" Pull word under cursor into LHS of a substitute
nnoremap <leader>z :%s#\<<c-r>=expand("<cword>")<cr>\>#<c-r>=expand("<cword>")<cr>#gc<left><left><left>
nnoremap <leader>Z :bufdo %s#\<<c-r>=expand("<cword>")<cr>\>#<c-r>=expand("<cword>")<cr>#gce<space><bar><space>update<left><left><left><left><left><left><left><left><left><left><left><left><left>

" move between windows
nnoremap <C-j> <C-W>j
nnoremap <C-k> <C-W>k
nnoremap <C-h> <C-W>h
nnoremap <C-l> <C-W>l

" move between tabs
nnoremap <silent> <C-PageDown> :tabnext<CR>
nnoremap <silent> <C-PageUp> :tabprevious<CR>
nnoremap <silent> <C-A> :tabprevious<CR>
nnoremap <silent> <C-S> :tabnext<CR>
nnoremap <silent> <C-Z> :tabnew<CR>

" alternate mappings for increase/decrease numeral
nnoremap gA <c-a>
nnoremap gZ <c-x>

" windowing
nnoremap <silent> z<cr> :call windowing#minimize_vertically()<cr>
nnoremap <silent> co4 :<c-u>vertical resize 84<cr>
nnoremap <silent> <leader>ha :<c-u>vsplit<cr>:<c-u>vertical resize 80<cr><C-W>l
nnoremap <silent> zh mzggzfip`z

" navigating
nnoremap <silent> <leader>nt <c-w>s:resize 17<cr>gg
nnoremap <leader>ng :split<cr>g<c-]>

" change buffers with ctrl-n and ctrl-p
nnoremap <silent> <C-p> :BufSurfBack<cr>
nnoremap <silent> <C-n> :BufSurfForward<cr>

" Use up and down keys to scroll up and down
nnoremap <Up> 3<C-y>
nnoremap <Down> 3<C-e>
nnoremap <Left> 10zh
nnoremap <Right> 10zl

" Smoother mouse scroll
inoremap <ScrollWheelUp> 2<C-Y>
inoremap <ScrollWheelDown> 2<C-E>
nnoremap <ScrollWheelUp> 2<C-Y>
nnoremap <ScrollWheelDown> 2<C-E>

" Mark current word (as with * but without movement)
" Switch HL / ^$ for faster movement
noremap H ^
noremap L $
noremap ^ H
noremap $ L

" Switch ` and '
noremap ` '
noremap ' `

nnoremap <silent> <leader>8 :let stay_star_view = winsaveview()<cr>*:call winrestview(stay_star_view)<cr>

" Easier linewise reselection of what you just pasted.
nnoremap <leader>v V`]

" Bash-like keys for the command line
cnoremap <C-A>	<Home>
cnoremap <C-E>	<End>
cnoremap <C-K>	<C-U>
cnoremap <C-P>	<Up>
cnoremap <C-N>	<Down>

" Move up and down in autocomplete with <c-j> and <c-k>
" inoremap <expr> <c-j> ("\<C-n>")
" inoremap <expr> <c-k> ("\<C-p>")

" Engage line-wise autocomplete with <c-f>
inoremap <c-f> <c-x><c-l>

" Indent the entire file
nnoremap <leader>= gg=G`'

" Pretty print entire file (if json)
nnoremap <leader>mJ :<c-u>%!json_pp<cr>
nnoremap <leader>mJS :<c-u>%!js-beautify -q -s 2 -f - <cr>
nnoremap <leader>mX :<c-u>%!xmllint --format --recover - <cr>

" Sort in paragraph
nnoremap <leader>ms Vip:sort<cr>
" Sort in paragraph, all but first row
nnoremap <leader>mS {jjV}k:sort<cr>
" Sort in indent
nmap <leader>mi ViI:sort<cr>
" Visual select whatever was just pasted from clipboard
nnoremap <leader>mv V`]=

" Tabularize things
nnoremap <leader>mt= :Tabularize /=/<cr>
nnoremap <leader>mt/ :Tabularize /\/\//<cr>
nnoremap <leader>mt, :Tabularize /, /r0<cr>

" Clean trailing whitespace
nnoremap <leader>mw mz:%s/\s\+$//<cr>:let @/=''<cr>`z

" Break up paramater list with newlines
nnoremap <silent> <leader>mp mz:s/(/(\r/<cr>:s/, /,\r/g<cr>jmx`zj=`x:noh<cr>

" Modify register
function! ModifyRegister()
    call inputsave()
    let l:reg = input("Enter a register: ")
    call inputrestore()
    return "let @".l:reg." = ".string(getreg(l:reg))
endfunction

nnoremap <leader>mq :<C-U><C-R>=ModifyRegister()<CR><C-E><C-F><Left>

" Move cpp // comment at end of line to line above
nnoremap <leader>mc $F/hhr<cr>kddpk$

" RST-style header creation
nnoremap <leader>mh yypVr

" Insertion esc conveniences
inoremap <c-o> <esc>o
inoremap <c-space> <esc>A;<esc>
noremap <c-space> A;<esc>

" jk/kj for <esc>
inoremap jk <esc>
inoremap kj <esc>

"Like D for yanking
noremap Y y$

" Copy/Paste with os buffer
noremap <leader>y "+y
noremap <leader>Y "+y$
nmap <leader>p "+p
nmap <leader>P "+P

" Copy current file path into os buffer
nnoremap <silent> <leader>fy :Ypwd<cr>
nnoremap <silent> <leader>fY :Ypfilename<cr>

" Copy entire file
nnoremap <leader><leader><leader> mz<esc>gg"+yG`zzz

" Save, quit, etc
nnoremap <silent> <leader>s :<C-U>w<cr>
nnoremap <silent> <leader>S :<C-U>w<cr>
nnoremap <silent> <leader>x :<C-U>wq<cr>
nnoremap <silent> <leader>X :<C-U>wqa<cr>
nnoremap <silent> <leader>T :<C-U>tabclose<cr>
nnoremap <silent> <leader>d :<C-U>confirm q<cr>
nnoremap <silent> <leader>D :<C-U>confirm qa<cr>
nnoremap <silent> <leader><leader>d :<C-U>bw!<cr>

" Good for switching between header .h and body .cpp files in CPP
" nnoremap <silent> <leader>h :<C-U>FSHere<cr>
" nnoremap <silent> <leader>hk :<C-U>FSSplitAbove<cr>
" nnoremap <silent> <leader>hj :<C-U>FSSplitBelow<cr>
" nnoremap <silent> <leader>hh :<C-U>FSSplitLeft<cr>
" nnoremap <silent> <leader>hl :<C-U>FSSplitRight<cr>
" nmap     <silent> <leader>ha :<C-U>FSSplitLeft<cr><c-h>zhco4<c-l>zh

" Neovim terminal settings

nnoremap <silent> <leader>t<space> :<c-u>terminal<cr>Afish<cr>
nnoremap <silent> <leader>tt :<c-u>tabnew<cr>:terminal<cr>Afish<cr>
nnoremap <silent> <leader>tj :<c-u>split<cr><c-w>j:terminal<cr>Afish<cr>
nnoremap <silent> <leader>tk :<c-u>split<cr>:terminal<cr>Afish<cr>
nnoremap <silent> <leader>th :<c-u>vsplit<cr>:terminal<cr>Afish<cr>
nnoremap <silent> <leader>tl :<c-u>vsplit<cr><c-w>l:terminal<cr>Afish<cr>

" Break window out of tabpage
nnoremap <leader>B <c-w>T
" Copy window out of tabpage
nnoremap <leader>b <c-w>s<c-w>T

" Maximize buffer toggling
nnoremap <silent> <leader><tab> :<C-U>MaximizerToggle<cr>
vnoremap <silent> <leader><tab> :<C-U>MaximizerToggle<cr>gv
inoremap <silent> <leader><tab> <c-o>:MaximizerToggle<cr>

" recover.vim
nnoremap <silent> <leader>Rh :<C-U>RecoveryPluginGet<cr>
nnoremap <silent> <leader>Rl :<C-U>RecoverPluginFinish<cr>

" w!! -> write even if you forgot sudo
cmap w!! w !sudo tee >/dev/null %

" Disable Ex mode
map Q <Nop>

" Mappings to interact with fugitive
nnoremap <silent> <leader>gs :<C-U>Git<cr>:call windowing#minimize_vertically()<cr>
nnoremap <silent> <leader>gd :<C-U>Gvdiff<cr>
nnoremap <silent> <leader>gb :<C-U>Git blame<cr>
nnoremap <silent> <leader>gw :<C-U>Gwrite<cr>
nnoremap <silent> <leader>gW :<C-U>Gwrite!<cr>
nnoremap <silent> <leader>gp :<C-U>Git push<cr>
nnoremap <leader>gm :<C-U>Git move <c-r>=expand('%:p')<cr>
nnoremap <leader>gl :<C-U>Git log --follow
nnoremap <leader>gL :<C-U>Git log --follow -- %<cr>
nnoremap <leader>gG :<C-U>Git grep
nnoremap <leader>gx :<C-U>Git commit -m ''<left>
nnoremap <leader>gA :<C-U>Git commit --amend --no-edit<cr>
nnoremap <leader>ga :<C-U>Git commit --amend<cr>
nnoremap <leader>gr :<C-U>Git checkout -- %
nnoremap <leader>gR :<C-U>Git reset --hard 
nnoremap <leader>gv :<C-U>GV --all<cr>
nnoremap <leader>gV :<C-U>GV! --all<cr>

" ALE Shortcuts {{{ "
nnoremap <leader><leader>as :<c-u>ALEFixSuggest<cr>
nnoremap <leader><leader>af :<c-u>ALEFix<cr>
nnoremap <leader><leader>ad :<c-u>ALEDetail<cr>
nnoremap <leader><leader>aD :<c-u>ALEDisable<cr>
nnoremap <leader><leader>ae :<c-u>ALEEnable<cr>
" }}} ALE Shortcuts "

" Get gittin!
nmap <leader>gg <c-w>s<c-w>T:Git<cr>/not staged<cr><c-n>:noh<cr>:call windowing#minimize_vertically()<cr>

" Close diff window, go to gstatus window, add file (or don't)
nmap     <leader>gn <c-w>h:q<cr><c-k>-
nmap     <leader>gN <c-w>h:q<cr><c-k><c-n>

" File management mappings
nnoremap <leader>er :<C-U>Rename <c-r>=expand('%:t')<cr>
nnoremap <leader>ed :<C-U>Remove
nnoremap <leader>em :<C-U>Move <c-r>=expand('%:p')<cr>
" Remove DOS line endings from unix file with mixed endings
nnoremap <leader>el :%s/\r$//<cr>

" Surround selected text with ${}
vmap $ S}i$<esc>

" Mappings for interacting with diff merges
nnoremap <silent> dgh :diffget \\2<cr>
nnoremap <silent> dgl :diffget \\3<cr>

" Misc mappings
nnoremap <leader>I i <esc>la <esc>h
nnoremap <silent> <leader><space> :noh<cr>
nnoremap <silent> <leader>ee :UltiSnipsEdit<cr>
nnoremap <silent> <leader>u :UndotreeToggle<cr>
nnoremap <silent> <leader>q :sign unplace *<cr>:Lclose<cr>:Cclose<cr>
nnoremap <silent> - mz:<c-u>:Switch<cr><esc>`z

" Option toggles
nnoremap =oD :IndentGuidesToggle<cr>
nnoremap =oR :RainbowToggle<cr>
nnoremap <silent> =oC :call g:ToggleColorColumn()<cr>
nnoremap <silent> =oL :call g:ToggleColorScheme()<cr>

" Goyo toggle
nnoremap <silent> =og :<C-U>Goyo 85%x95%<cr>
nnoremap <silent> =oG :<C-U>Goyo 75%x95%<cr>

" Go to tabs with F-keys
nnoremap <F1> 1gt
nnoremap <F2> 2gt
nnoremap <F3> 3gt
nnoremap <F4> 4gt
nnoremap <F5> 5gt
nnoremap <F6> 6gt
nnoremap <F7> 7gt
nnoremap <F8> 8gt
nnoremap <F9> 9gt
nnoremap <F10> 10gt
nnoremap <F11> 11gt
nnoremap <F12> 12gt

" Accidentally pressing F1 is to press ESC
imap <F1> <esc>
cmap <F1> <esc>
xmap <F1> <esc>
smap <F1> <esc>
lmap <F1> <esc>

" Spell checking mappings {{{ "
" Pressing <leader>ft will toggle and untoggle spell checking,
" fe sets checking to english and fs sets checking to swedish.
nnoremap <silent> <leader>fz :setlocal spell!<cr>
nnoremap <silent> <leader>fs :setlocal spelllang=sv<cr>
nnoremap <silent> <leader>fe :setlocal spelllang=en<cr>
" }}} Spell checking mappings "
" }}} Keymaps "
